{
  "resolvedId": "/home/user/chakaralaya/Chakaralaya/node_modules/framer-motion/dist/es/motion/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "\"use client\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { useRender } from '../render/dom/use-render.mjs';\nimport { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';\nimport { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';\nimport { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    const useVisualState = isSVGComponent(Component)\n        ? useSVGVisualState\n        : useHTMLVisualState;\n    function MotionDOMComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));\n    }\n    MotionDOMComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${Component.displayName ?? Component.name ?? \"\"})`}`;\n    const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? warning(false, strictMessage, \"lazy-strict-mode\")\n            : invariant(false, strictMessage, \"lazy-strict-mode\");\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\nexport { createMotionComponent };\n",
      "start": 1762100729509,
      "end": 1762100729636,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "start": 1762100729636,
      "end": 1762100729636,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "\"use client\";\nimport { jsxs, jsx } from \"react/jsx-runtime\";\nimport { warning, invariant } from \"motion-utils\";\nimport { forwardRef, useContext } from \"react\";\nimport { LayoutGroupContext } from \"../context/LayoutGroupContext.mjs\";\nimport { LazyContext } from \"../context/LazyContext.mjs\";\nimport { MotionConfigContext } from \"../context/MotionConfigContext.mjs\";\nimport { MotionContext } from \"../context/MotionContext/index.mjs\";\nimport { useCreateMotionContext } from \"../context/MotionContext/create.mjs\";\nimport { useRender } from \"../render/dom/use-render.mjs\";\nimport { isSVGComponent } from \"../render/dom/utils/is-svg-component.mjs\";\nimport { useHTMLVisualState } from \"../render/html/use-html-visual-state.mjs\";\nimport { useSVGVisualState } from \"../render/svg/use-svg-visual-state.mjs\";\nimport { isBrowser } from \"../utils/is-browser.mjs\";\nimport { featureDefinitions } from \"./features/definitions.mjs\";\nimport { loadFeatures } from \"./features/load-features.mjs\";\nimport { motionComponentSymbol } from \"./utils/symbol.mjs\";\nimport { useMotionRef } from \"./utils/use-motion-ref.mjs\";\nimport { useVisualElement } from \"./utils/use-visual-element.mjs\";\nfunction createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  const useVisualState = isSVGComponent(Component) ? useSVGVisualState : useHTMLVisualState;\n  function MotionDOMComponent(props, externalRef) {\n    let MeasureLayout;\n    const configAndProps = {\n      ...useContext(MotionConfigContext),\n      ...props,\n      layoutId: useLayoutId(props)\n    };\n    const { isStatic } = configAndProps;\n    const context = useCreateMotionContext(props);\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      useStrictMode(configAndProps, preloadedFeatures);\n      const layoutProjection = getProjectionFunctionality(configAndProps);\n      MeasureLayout = layoutProjection.MeasureLayout;\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n    }\n    return jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });\n  }\n  MotionDOMComponent.displayName = `motion.${typeof Component === \"string\" ? Component : `create(${Component.displayName ?? Component.name ?? \"\"})`}`;\n  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n  ForwardRefMotionComponent[motionComponentSymbol] = Component;\n  return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n  const layoutGroupId = useContext(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n  const isStrict = useContext(LazyContext).strict;\n  if (false) {\n    const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n    configAndProps.ignoreStrict ? warning(false, strictMessage, \"lazy-strict-mode\") : invariant(false, strictMessage, \"lazy-strict-mode\");\n  }\n}\nfunction getProjectionFunctionality(props) {\n  const { drag, layout } = featureDefinitions;\n  if (!drag && !layout)\n    return {};\n  const combined = { ...drag, ...layout };\n  return {\n    MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props) ? combined.MeasureLayout : void 0,\n    ProjectionNode: combined.ProjectionNode\n  };\n}\nexport { createMotionComponent };\n",
      "start": 1762100729636,
      "end": 1762100729658,
      "order": "normal-normal",
      "sourcemaps": null
    },
    {
      "name": "vite:reporter",
      "start": 1762100729658,
      "end": 1762100729658,
      "order": "normal"
    }
  ]
}
